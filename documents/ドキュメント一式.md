# 保健室予約アプリ（社内向け）プロジェクト ドキュメント集  
**作成日：2025‑12‑22** **バージョン：0.1 (草案)**  

> 本書は、これまでのやり取りで決定した要件・設計情報をベースに作成した **プロジェクト憲章から運用マニュアルまでの包括的ドキュメント** です。  
> 不明確／未確定項目については **「TBD」** と記載し、後工程で埋めていくことを前提とします。

---

## 1️⃣ プロジェクト憲章 / プロジェクト計画書

| 項目 | 内容 |
|------|------|
| **プロジェクト名称** | 社内保健室予約システム（仮称） |
| **目的・背景** | - 社員の健康診断結果が「要注意」になった際に、看護師が迅速に医師へ呼び出し予約を行える仕組みが社内に無い。<br>- 現在は紙ベースで目視判定・Power Automate でメール送信という手作業が多く、ヒューマンエラーや遅延が発生している。<br>- Azure AD の社員情報を活用し、Web UI から予約・スケジュール管理・リマインダー送信までを一元化することで **業務効率化** と **情報の可視化** を実現する。 |
| **スコープ（対象機能）** | 1. 社員情報取得（Azure AD からの取得は Mock に置き換え）<br>2. 看護師・医師情報管理（CRUD）<br>3. 医師診療スケジュール登録（日時ブロック単位）<br>4. 診療曜日設定<br>5. 予約作成・編集・削除（社員 ↔︎ 医師 の紐付）<br>6. メールテンプレート管理（リマインダー用）<br>7. リマインダー設定（X日前のYY時に自動送信）<br>8. 予約一覧・検索画面（部署・期間・医師フィルタ）<br>9. バックアップ（PostgreSQL の pg_dump → OneDrive 同期フォルダ） |
| **除外項目** | - 健康診断結果のデジタル化／自動判定ロジック（次回バージョンで検討）<br>- 本番環境での Azure AD / Microsoft Graph の実装（現時点は Mock）<br>- 多言語対応、モバイルネイティブアプリ |
| **成功基準 (KPI・MVP 定義)** | - **MVP**：社員が Web UI から予約を作成し、看護師がメールリマインダー（Mock ログ）を受信できること。<br>- **KPI** <ul><li>予約登録 → 2 秒以内に API がレスポンス</li><li>月間アクティブユーザー ≥ 80%（対象部署 50 名）</li><li>リマインダー送信失敗率 ≤ 1%</li></ul> |
| **主要ステークホルダー & 役割** | - **HR 部門（プロダクトオーナー）**：要件定義・業務フロー確認<br>- **システム管理部**：WSL/Docker 環境、OneDrive バックアップ設定<br>- **開発チーム（フルスタックエンジニア）**：設計・実装・テスト全般<br>- **看護師リーダー**：画面 UI/UX フィードバック、メールテンプレート提供<br>- **医師代表者**：診療スケジュール要件確認 |
| **予算・リソース概算** | - 人員：1 名フルスタックエンジニア（パートタイム）＋ 0.5 名インフラ管理者<br>- ハードウェア：既存 Windows 11 Enterprise PC + WSL2 （追加費用なし）<br>- ソフトウェア・ライセンス：Docker Desktop 無料版は使用不可 → Docker Engine (WSL) のみ利用、その他 OSS（Node, PostgreSQL 等）は無料<br>- 合計概算コスト：**¥0（社内リソースのみ）** |
| **タイムライン（マイルストーン）** | 1. **要件固め** – 2025‑12‑28<br>2. **プロトタイプ実装 (Mock)** – 2026‑01‑15<br>3. **MVP デモ** – 2026‑02‑05<br>4. **内部レビュー & 改修** – 2026‑02‑20<br>5. **本番環境準備（Azure AD 実装・TLS 設定）** – 2026‑03‑10 (TBD)<br>6. **リリース** – 2026‑04‑01 (予定) |

---

## 2️⃣ 要件定義書

### 2‑1️⃣ ユーザーストーリー／ユースケース一覧

| ID | アクター | ストーリー（As a … I want … so that …） |
|----|----------|-------------------------------------------|
| US01 | 社員 | **健康診断結果が要注意** と判断されたら、システム上で医師の空き時間を確認し、予約できるようにしたい。 |
| US02 | 看護師 | 医師のスケジュール（診療可能時間帯）を日単位で登録・編集したい。 |
| US03 | 看護師 | 診療曜日（例：月〜金）だけをカレンダー表示させ、他の日は非表示にしたい。 |
| US04 | 医師 | 自分の診療スケジュールを確認し、必要に応じて変更できるようにしたい。 |
| US05 | 看護師 | 予約が確定したら、テンプレート化されたメール（社員名・医師名・日時）で自動通知したい。 |
| US06 | HR 担当者 | 部署別・期間別に予約状況をレポートできるようにしたい。 |
| US07 | システム管理者 | DB のバックアップが OneDrive に自動保存され、復元手順が明確であることを確認したい。 |

### 2‑2️⃣ 機能要件（入力・出力・画面遷移・ビジネスロジック）

| 機能 | 入力項目 | 出力／画面遷移 | 主なビジネスロジック |
|------|----------|----------------|---------------------|
| **社員情報取得** | 社員番号（テキスト） | JSON `{ employee: {...} }` （Mock データ） | Azure AD から `employeeNumber` で検索 → 見つからなければエラー (404) |
| **医師 CRUD** | 名前、敬称、診療時間（分） | 成功時は作成・更新された Doctor オブジェクト JSON。失敗時はバリデーションエラーメッセージ | `minDuration ≤ defaultDuration ≤ maxDuration` の整合性チェック |
| **看護師 CRUD** | 社員番号、敬称 | 作成/更新結果 JSON | 社員情報取得 → 既存 Employee と紐付け |
| **診療スケジュール登録** | 医師ID、開始日時（ISO UTC）、終了日時（ISO UTC） | 登録成功時は Schedule オブジェクト返却 | <ul><li>開始 < 終了 の検証</li><li>同一医師の重複ブロック防止 (`@unique([doctorId,startUtc,endUtc])`)</li></ul> |
| **診療曜日設定** | 曜日配列（0‑6） | 設定保存成功 JSON | 既存レコード全削除 → 新規作成 |
| **予約 CRUD** | 医師ID、社員番号、開始UTC、終了UTC、（任意）看護師ID | 予約一覧画面へリダイレクト／JSON レスポンス | <ul><li>社員番号 → Employee.id に変換</li><li>医師スケジュール内かチェック</li><li>既存予約と時間重複が無いことを保証</li></ul> |
| **メールテンプレート管理** | テンプレート名、件名、本文（Mustache） | 作成/更新結果 JSON | 文字列長・必須項目のバリデーション |
| **リマインダー設定** | X日前、送信時刻(UTC) | 設定保存成功 JSON | `0 ≤ sendHour ≤ 23` の検証 |
| **リマインダー自動送信（Cron）** | – | ログ (`logs/email.log`) と DB に `ReminderSent` を記録 | <ul><li>現在時刻から `daysBefore`・`sendHour` を算出</li><li>対象予約取得 → テンプレート展開 → メール送信（Mock）</li></ul> |
| **検索画面** | 部署、開始日–終了日、医師ID（任意） | フィルタ結果のテーブル表示 | DB の `WHERE` 条件組み立て |

### 2‑3️⃣ 非機能要件概要

| 項目 | 要件 |
|------|------|
| **パフォーマンス** | API 応答時間 ≤ 2 秒（予約作成・検索）<br>同時接続数 20 ユーザーを想定したスループット ≥ 30 req/s |
| **可用性** | 開発環境は **99.5%** の稼働率（Docker コンテナ自動再起動） |
| **セキュリティ** | 現行は社内ネットワーク限定、Mock モードで認証なし。将来的に Azure AD 認証・HTTPS (TLS 1.2) を導入予定。|
| **スケーラビリティ** | コンテナ化により水平スケールが可能（K8s 移行を想定） |
| **運用性** | 毎日 00:00 に `pg_dump` → OneDrive 同期フォルダへ保存。ログはローテーション (7 日保持)。|

### 2‑4️⃣ 受入基準（Acceptance Criteria）

1. **予約作成フロー** が UI 上で完結し、バックエンドに POST → 200 OK が返り、メールログが出力されること。  
2. **医師スケジュール** に登録した時間帯外の予約は API が `400 Bad Request` を返すこと。  
3. **診療曜日設定** が変更されたら、カレンダー画面で該当曜日以外がグレーアウト（非表示）になること。  
4. **リマインダージョブ** が毎時実行され、対象予約に対して 1 通だけメールログが出力されること（重複送信なし）。  
5. **バックアップ** が OneDrive に保存され、`docker exec -it db pg_dump …` が手動でも成功すること。  

---

## 3️⃣ 非機能要件仕様書

| 項目 | 詳細 |
|------|------|
| **パフォーマンス目標** | - **平均応答時間**：GET `/reservations` ≤ 1.5 秒、POST `/reservations` ≤ 2 秒。<br>- **スループット**：同時 20 ユーザーで 30 req/s を維持（ローカル Docker 環境で測定）。 |
| **可用性・冗長構成 (SLA)** | - 開発環境は単一ホスト上の Docker コンテナ → 再起動自動化 (`restart: always`)。<br>- 本番移行時は **2 台以上** の VM にコンテナをデプロイし、ロードバランサでフェイルオーバーを実装（TBD）。 |
| **セキュリティ要件** | - 現在は **内部ネットワーク限定**、認証なし（Mock モード）<br>- 本番では **Azure AD OIDC** による JWT 発行 → `Authorization: Bearer <token>` ヘッダーで保護。<br>- データ転送は **HTTPS (TLS 1.2+)** を必須化（Docker の Nginx に TLS 終端）。<br>- DB パスワードは `.env` で管理し、コンテナ環境変数に注入。 |
| **脆弱性基準** | - `npm audit` が **Critical** レベルの脆弱性を 0 件に保つこと。<br>- 静的解析（ESLint + security plugin）で OWASP Top 10 の指摘が無い状態。 |
| **スケーラビリティ・拡張性** | - アプリは **マイクロサービス化可能なモジュール構成**（NestJS モジュール単位）。<br>- コンテナイメージは `docker-compose` から **Kubernetes デプロイ** へ置き換え可能（YAML 用意済み TBD）。 |
| **運用・保守要件** | - **バックアップ**：毎日 00:00 に `pg_dump` → `/backup` （OneDrive 同期）に保存。保持期間は 30 日（ローカルで自動削除スクリプト TBD）。<br>- **ログ保持**：アプリの標準出力は Docker のローテーション (`max-size:10m`, `max-file:7`) を使用。メール送信は `logs/email.log` に追記し、同様に 30 日でローテート。 |

---

## 4️⃣ 画面設計書 (UI/UX Design Specification)

| 項目 | 内容 |
|------|------|
| **ワイヤーフレーム / モック画像** | - **トップページ（予約カレンダー）**：ヘッダーに「日／週／月」切替ボタン、前後ナビゲーション、診療曜日フィルタ。<br>- **予約作成ダイアログ**：医師選択ドロップダウン、開始・終了日時ピッカー、看護師（任意）入力。<br>- **設定画面**：診療曜日チェックボックス、リマインダー設定フォーム、メールテンプレートエディタ。 <br>※ 画像は現在 **TBD** （Figma / Adobe XD 等で作成予定）。 |
| **画面遷移図（フローチャート）** | ```
[ログイン(省略)] → [予約カレンダー] ↔ (日/週/月 切替)
   │
   ├─▶ 【予約新規】 → 入力 → 成功→ カレンダー更新
   ├─▶ 【医師設定】 → CRUD 操作 → 戻る
   ├─▶ 【看護師設定】 → CRUD
   └─▶ 【リマインダー設定】 → 保存
``` |
| **UI コンポーネント一覧と仕様** | - **ボタン**：高さ 40 px、幅自動、背景 `#2563EB`（Tailwind `bg-blue-600`）、ホバーで暗くなる。<br>- **入力フィールド**：`border-gray-300`、フォーカス時 `ring-2 ring-blue-200`。<br>- **カレンダーセル**：`min-h-[100px]`、診療曜日は標準表示、非対象日は `opacity-50`。<br>- **モーダル**：Tailwind の `fixed inset-0 flex items-center justify-center bg-black/30`。 |
| **アクセシビリティ要件 (WCAG)** | - コントラスト比 ≥ 4.5:1（テキスト・アイコン）。<br>- キーボード操作で全てのインタラクションが可能（Tab → Enter）。<br>- ARIA ラベルを適切に付与（例：`aria-label="予約作成ボタン"`）。 |
| **インタラクション詳細** | - 入力エラーは即時表示 (`onBlur` 時に `class-validator` の結果を反映)。<br>- 成功メッセージはトーストで 3 秒間表示。<br>- カレンダーのセルクリック → 該当日の予約一覧モーダルがスライドイン。 |

---

## 5️⃣ データモデル設計書

### 5‑1️⃣ ER 図（テキストベース）

```
Employee ──< Doctor
   │          (1:1)    // Employee が医師情報を持つ
   └──< Nurse               // Employee が看護師情報を持つ
   └──< Reservation (患者)
Doctor ──< Reservation (担当医師)
Nurse  ──< Reservation (任意の担当看護師)

Doctor ──< DoctorSchedule
Workday (診療曜日) – 独立テーブル、予約検索時に参照

EmailTemplate ←→ ReminderConfig (1:多) → ReminderSent ←← Reservation
UserTimezone (社員ごとのタイムゾーン情報)
```

### 5‑2️⃣ テーブル定義（主要カラム）

| テーブル | カラム名 | データ型 | 制約・インデックス |
|----------|----------|----------|--------------------|
| **Employee** | `id` | UUID (PK) | - |
| | `employeeNumber` | VARCHAR(20) | UNIQUE |
| | `name` | VARCHAR(100) | NOT NULL |
| | `email` | VARCHAR(200) | NOT NULL, UNIQUE |
| | `companyName` | VARCHAR(100) |  |
| | `department` | VARCHAR(100) |  |
| | `phoneNumber` | VARCHAR(15) | 正規表現チェック (`^\d{3}-\d{4}-\d{4}$`) |
| **Doctor** | `id` | UUID (PK) | - |
| | `employeeId` | UUID | UNIQUE, FK → Employee(id) |
| | `title` | VARCHAR(20) |  |
| | `minDurationMin` | INT | NOT NULL |
| | `defaultDurationMin` | INT | NOT NULL |
| | `maxDurationMin` | INT | NOT NULL |
| **Nurse** | `id` | UUID (PK) | - |
| | `employeeId` | UUID | UNIQUE, FK → Employee(id) |
| | `title` | VARCHAR(20) |  |
| **DoctorSchedule** | `id` | UUID (PK) | - |
| | `doctorId` | UUID | FK → Doctor(id) |
| | `startUtc` | TIMESTAMP WITH TIME ZONE | NOT NULL |
| | `endUtc`   | TIMESTAMP WITH TIME ZONE | NOT NULL |
| **Reservation** | `id` | UUID (PK) | - |
| | `doctorId` | UUID | FK → Doctor(id), NOT NULL |
| | `employeeId` | UUID | FK → Employee(id), NOT NULL |
| | `nurseId` | UUID | FK → Nurse(id), Nullable |
| | `startUtc` | TIMESTAMP WITH TIME ZONE | NOT NULL |
| | `endUtc`   | TIMESTAMP WITH TIME ZONE | NOT NULL |
| | `status`   | VARCHAR(20) | DEFAULT `'PENDING'` |
| **Workday** | `id` | UUID (PK) | - |
| | `dayOfWeek` | INT (0‑6) | CHECK (`dayOfWeek BETWEEN 0 AND 6`) |
| **EmailTemplate** | `id` | UUID (PK) | - |
| | `name` | VARCHAR(50) | UNIQUE |
| | `subject` | VARCHAR(200) | NOT NULL |
| | `body`   | TEXT | NOT NULL |
| **ReminderConfig** | `id` | UUID (PK) | - |
| | `daysBefore` | INT | NOT NULL |
| | `sendHour`   | INT | CHECK (`sendHour BETWEEN 0 AND 23`) |
| **ReminderSent** | `id` | UUID (PK) | - |
| | `reservationId` | UUID | FK → Reservation(id) |
| | `configId`      | UUID | FK → ReminderConfig(id) |
| | `sentAtUtc`     | TIMESTAMP WITH TIME ZONE | DEFAULT now() |
| **UserTimezone** | `userId` | VARCHAR(50) (PK) | Azure AD Object ID |
| | `timezone` | VARCHAR(100) | NOT NULL |

### 5‑3️⃣ 正規化レベルと理由

- **第1正規形（1NF）**：全カラムは原子値。  
- **第2正規形（2NF）**：主キーが単一の UUID で、非キー属性は完全関数従属。  
- **第3正規形（3NF）**：派生属性（例：`Employee.email` の重複）は排除し、外部キーにより参照整合性を保持。  

> この設計により **更新異常** を防止し、データの一貫性が保たれます。

### 5‑4️⃣ データ永続化戦略

- **RDBMS**：PostgreSQL（ACID 保証、リレーションが必須なため）  
- **キャッシュ層**：現段階では不要。将来的に予約検索のスループット向上が必要になったら Redis を導入予定（TBD）。  

---

## 6️⃣ API設計書

| No. | メソッド | エンドポイント | 要求ボディ / パラメータ | 成功レスポンス例 | ステータスコード |
|-----|----------|----------------|------------------------|------------------|-------------------|
| 1 | GET | `/api/v1/employees/:number` | `:number` = 社員番号 | `{ "data": { "id":"...", "name":"...", ... }}` | 200 |
| 2 | POST | `/api/v1/doctors` | `CreateDoctorDto`（JSON） | 作成された Doctor オブジェクト | 201 |
| 3 | GET | `/api/v1/doctors` | - | Doctor 配列 | 200 |
| 4 | PATCH | `/api/v1/doctors/:id` | 部分更新 DTO | 更新後オブジェクト | 200 |
| 5 | DELETE | `/api/v1/doctors/:id` | - | `{ "deleted": true }` | 200 |
| 6 | POST | `/api/v1/nurses` | `CreateNurseDto`（社員番号） | Nurse オブジェクト | 201 |
| 7 | GET | `/api/v1/reservations` | クエリ: `doctorId?`, `employeeId?`, `startDate?`, `endDate?` | Reservation 配列 | 200 |
| 8 | POST | `/api/v1/reservations` | `CreateReservationDto`（医師ID・社員番号・開始UTC・終了UTC） | 作成予約オブジェクト | 201 |
| 9 | PATCH | `/api/v1/reservations/:id` | `UpdateReservationDto` | 更新後オブジェクト | 200 |
|10 | DELETE | `/api/v1/reservations/:id` | - | `{ "deleted": true }` | 200 |
|11 | POST | `/api/v1/schedules/days` | `{ daysOfWeek: [0,1,2,3,4] }` | 保存成功オブジェクト | 201 |
|12 | GET | `/api/v1/schedules/days` | - | `[0,1,2,3,4]` | 200 |
|13 | POST | `/api/v1/email-templates` | `CreateEmailTemplateDto` | 作成テンプレートオブジェクト | 201 |
|14 | GET | `/api/v1/email-templates` | - | テンプレート配列 | 200 |
|15 | POST | `/api/v1/reminders` | `{ daysBefore: 3, sendHour: 9 }` | 作成 ReminderConfig | 201 |
|16 | GET | `/api/v1/reminders` | - | ReminderConfig 配列 | 200 |
|17 | GET | `/api/v1/timezones?userId=xxxx` | クエリ `userId` | `{ "timezone": "Asia/Tokyo" }` | 200 |
|18 | POST | `/api/v1/timezones` | `{ userId: "...", timezone: "Asia/Tokyo" }` | 保存成功オブジェクト | 201 |

### 認可方式

- **現在（Mock）**：認証・認可なし（社内ネットワーク限定）。  
- **将来予定**：Azure AD の OIDC → JWT 発行、バックエンドは `@nestjs/passport` + `JwtStrategy` にてトークン検証。全エンドポイントに `@UseGuards(AuthGuard('jwt'))` を付与。

### エラーハンドリング規約

| HTTP ステータス | シナリオ | レスポンス例 |
|-----------------|----------|--------------|
| 400 | バリデーション失敗、時間重複など | `{ "statusCode":400, "message":[ "startUtc must be before endUtc" ], "error":"Bad Request" }` |
| 401 | JWT が無効・未提供（本番） | 同上、 `"Unauthorized"` |
| 403 | 権限不足（将来実装時） | `"Forbidden"` |
| 404 | リソース未発見（社員番号不正等） | `{ "statusCode":404, "message":"Employee not found", "error":"Not Found" }` |
| 500 | サーバ内部エラー | 同上、 `"Internal Server Error"` |

---

## 7️⃣ アーキテクチャ設計書

### 7‑1️⃣ 全体構成図（テキスト）

```
[ブラウザ] <--HTTPS (TLS)--> [NGINX (Docker コンテナ)] <--HTTP--> [NestJS API (Docker コンテナ)]
                                          |
                                          v
                                   [PostgreSQL DB (Docker コンテナ)]
                                          |
                                          v
                                 [OneDrive 同期フォルダ（バックアップ）]
```

- **フロントエンド**：React + Vite、`/api/v1/*` へプロキシ。  
- **バックエンド**：NestJS (TypeScript) → Prisma ORM → PostgreSQL。  
- **外部サービス**（将来）：Azure AD Graph API（社員情報取得）・Microsoft Graph `sendMail`（本番メール送信）。  

### 7‑2️⃣ コンポーネント分割と責務

| コンポーネント | 責務 |
|----------------|------|
| **React UI** | 画面描画、ユーザー入力バリデーション、API 呼び出し（axios） |
| **NestJS Controllers** | HTTP リクエスト受信、DTO バリデーション、ステータスコード付与 |
| **NestJS Services** | ビジネスロジック（予約重複チェック、スケジュール検証）、Prisma への CRUD 呼び出し |
| **Prisma Service** | DB 接続管理、トランザクションラッパー |
| **Cron Job (ReminderJob)** | 時間ベースでリマインダー検索・メール送信（Mock） |
| **Docker Compose** | コンテナオーケストレーション、ネットワーク・ボリューム管理 |
| **OneDrive バックアップスクリプト** | `pg_dump` → `/backup`（自動同期） |

### 7‑3️⃣ デプロイメントモデル

- **開発環境**：ローカル Windows 11 Enterprise + WSL2 → Docker Compose により単一ホスト上でフロント・バックエンド・DB を起動。  
- **本番候補**（将来）：
  - **IaaS**：Azure VM 上に Docker Engine、同様の `docker-compose.yml` でデプロイ。  
  - **PaaS**：Azure App Service for Containers + Azure Database for PostgreSQL。  
  - **K8s**：AKS クラスタへ移行し、Helm Chart でマニフェスト管理（TBD）。  

### 7‑4️⃣ 技術スタック選定理由

| 項目 | 選択技術 | 理由 |
|------|----------|------|
| **バックエンド言語** | TypeScript (NestJS) | 型安全、デコレータベースのバリデーション、Prisma との相性が良い。 |
| **ORM** | Prisma | スキーマ駆動で型生成が自動、マイグレーションがシンプル。 |
| **フロントエンド** | React + Vite + TailwindCSS | 開発速度・ホットリロードが高速、Tailwind で UI 統一感を簡単に実装。 |
| **コンテナ化** | Docker (Compose) | 環境依存を排除し、社内 PC のみで完結できる。 |
| **CI/CD** | GitHub Actions + Docker BuildKit | GitHub リポジトリだけで完結、プッシュ時に自動テスト・ビルドが走る。 |
| **バックアップ先** | OneDrive (Windows 同期) | 社内 PC が既に利用しているクラウドストレージで追加コスト不要。 |

### 7‑5️⃣ パターン・アンチパターンの適用箇所

| パターン | 適用場所 |
|----------|-----------|
| **Repository Pattern**（Prisma Service） | データアクセス抽象化、テスト容易性向上 |
| **Dependency Injection** (NestJS) | 全サービス・コントローラで利用し、モック差し替えが簡単 |
| **Cron Job** (Schedule Module) | リマインダー自動送信のスケジューリング |
| **Factory Method**（メールテンプレート生成） | `renderTemplate` ユーティリティで実装 |
| **Anti‑Pattern: God Object** | 回避：各機能は独立モジュールに分割、サービスは薄く保つ |
| **Anti‑Pattern: Over‑Engineering** | 現状は Mock モードとシンプル構成で抑えており、本番向けの認証・TLS は後工程で追加予定 |

---

## 8️⃣ インフラ設計書 / 環境構成図

| 項目 | 内容 |
|------|------|
| **ネットワークトポロジ** | - WSL2 の Linux ブリッジネットワーク上に Docker デフォルトブリッジが作成。<br>- コンテナは同一内部ネットワーク `health-app_default` に所属し、ポートマッピングで外部へ公開（3000, 80）。 |
| **サーバー/コンテナスペック** | - **CPU**：2 vCPU (WSL のリソース割り当て) <br>- **メモリ**：4 GB （Docker Desktop の代替として WSL に割り当て）<br>- **ストレージ**：ローカル SSD、バックアップは OneDrive 同期フォルダ（外部ディスクに自動保存）。 |
| **CI/CD パイプライン構成** | 1. `push` → GitHub Actions 起動<br>2. `npm ci` (workspace 全体)<br>3. Lint → Unit Tests (Jest / Playwright) <br>4. Docker Build（Backend・Frontend）<br>5. （本番環境向けに）Docker イメージを GHCR へプッシュ、K8s/VM にデプロイ（TBD）。 |
| **DNS / ロードバランサ** | 現在はローカルホスト (`localhost`) のみ。将来的に Azure DNS と Application Gateway を導入予定（TBD）。 |
| **CDN 設定** | 静的資産 (React ビルド) は Nginx がキャッシュヘッダーを付与。外部 CDN は未使用（TBD）。 |
| **モニタリング・ログ収集設計** | - コンテナ標準出力 → Docker のローテーション (`max-size:10m`) <br>- アプリ側は `winston` で JSON ログを出力し、`docker logs` から取得可能。<br>- 将来的に Azure Monitor / Prometheus + Grafana を導入予定（TBD）。 |

---

## 9️⃣ セキュリティ設計書

| 項目 | 内容 |
|------|------|
| **脅威モデル (STRIDE)** | <ul><li>**Spoofing**：外部からの不正アクセス → 現在は社内ネットワーク限定、将来 Azure AD OIDC で認証。</li><li>**Tampering**：データ改ざん → DB はローカル PostgreSQL、バックアップは OneDrive 暗号化保存（OneDrive の at‑rest encryption）。</li><li>**Repudiation**：操作記録が残らない → すべての API 呼び出しは `requestId` を付与し、ログに永続化。</li><li>**Information Disclosure**：機密情報漏洩 → 環境変数で管理し `.env` は .gitignore。HTTPS (TLS) が必須になる段階で導入。</li><li>**Denial of Service**：過負荷 → Rate limiting (Express-rate-limit) を将来的に追加（TBD）。</li><li>**Elevation of Privilege**：権限昇格 → ロールベースの RBAC を Azure AD のグループで実装予定（TBD）。</li></ul> |
| **認証・認可フロー** | - 現在は **なし**（Mock）<br>- 本番では **Azure AD OIDC** → フロントがトークン取得、バックエンドが JWT 検証。<br>- エンドポイントごとに `@Roles(['admin','nurse'])` などのガードを付与予定。 |
| **データ暗号化方針** | - **転送時**：HTTPS (TLS 1.2+) を必須化（Nginx の SSL 終端）。<br>- **保存時**：PostgreSQL の `pgcrypto` 拡張で必要に応じて列レベル暗号化、OneDrive は Microsoft が提供する at‑rest 暗号化を利用。 |
| **OWASP Top 10 対策一覧** | 1. **Injection** → Prisma のパラメータバインディングで防止。<br>2. **Broken Authentication** → Azure AD OIDC に委譲。<br>3. **Sensitive Data Exposure** → 環境変数・TLS。<br>4. **XML External Entities (XXE)** → JSON API のみ使用。<br>5. **Broken Access Control** → RBAC ガード実装（TBD）。<br>6. **Security Misconfiguration** → Dockerfile で最小権限ユーザー (`node` ユーザー) 使用。<br>7. **Cross‑Site Scripting (XSS)** → React の自動エスケープ、CSP 設定（TBD）。<br>8. **Insecure Deserialization** → JSON パースは標準 `JSON.parse`。<br>9. **Using Components with Known Vulnerabilities** → 定期的に `npm audit` 実行。<br>10. **Insufficient Logging & Monitoring** → Winston ログ + Docker log‑driver。 |
| **インシデント対応手順** | 1. アラート受信（監視ツール）→担当者 (Ops) が Slack に通知。<br>2. 初期調査：ログ解析、コンテナステータス確認。<br>3. 隔離：問題のコンテナを `docker stop` または `kubectl delete pod`（本番）。<br>4. 復旧：バックアップから DB リストア (`pg_restore`) → コンテナ再起動。<br>5. 報告書作成・根本原因分析 (RCA)。 |
| **その他** | - **パスワードポリシー**は Azure AD に委譲。<br>- **脆弱性スキャン**：GitHub Dependabot + `npm audit`（自動 PR）。 |

---

## 10️⃣ テスト計画書

| レベル | 内容 | 主なツール |
|--------|------|------------|
| **単体テスト** | 各 Service/Util のロジック検証（例：予約重複チェック、メールテンプレート展開） | Jest (NestJS) |
| **結合テスト** | Controller ↔︎ Service の統合、DTO バリデーション、エラーハンドリング | SuperTest + Jest |
| **システムテスト** | フロントとバックエンドのエンドツーエンドフロー（予約作成→メールログ） | Playwright (Chromium) |
| **受入テスト** | ステークホルダーが定義したユーザーストーリーを検証（US01‑US07） | 手動 + Cypress (UI 自動化の予備) |
| **パフォーマンステスト** | 同時リクエスト 30 req/s のスループット測定、応答時間 < 2 秒 | k6 / Artillery |
| **セキュリティテスト** | OWASP ZAP による自動脆弱性スキャン、`npm audit` 実行 | OWASP ZAP, npm audit |

### テストケース作成基準とサンプル

- **命名規則**：`<機能>_<条件>_期待結果` 例 `Reservation_Create_Overlap_Failure`  
- **必須項目**：入力データ、前提状態（DB に既存レコード有無）、実行手順、期待レスポンス・ステータス。  

#### サンプルテストケース（Jest）

```ts
describe('ReservationService.create', () => {
  it('should reject reservation that overlaps existing one', async () => {
    // 前提：同一医師で既に予約が存在
    await prisma.reservation.create({ data: { doctorId, employeeId, startUtc: '2026-01-10T09:00:00Z', endUtc: '2026-01-10T09:30:00Z' } });

    // 実行：重複予約リクエスト
    await expect(
      service.create({
        doctorId,
        employeeNumber: 'E001',
        startUtc: '2026-01-10T09:15:00Z',
        endUtc:   '2026-01-10T09:45:00Z',
      }),
    ).rejects.toThrow(BadRequestException);
  });
});
```

### テスト環境構築手順

1. `docker compose up -d`（DB・バックエンド・フロント）  
2. `npm run test`（backend） → Jest が Prisma のテスト DB (`postgres://postgres:postgres@localhost:5432/healthapp_test`) に接続。  
3. `npx playwright test` → Headless Chromium で UI テスト実行。  

### 品質指標

| 指標 | 目標 |
|------|------|
| **バグ密度** | 0.5 バグ / KLOC（リリース前） |
| **テストカバレッジ** | Unit ≥ 80% (statements) |
| **CI 成功率** | 100%（全ステージ通過） |
| **パフォーマンス SLA** | 平均応答 ≤ 2 秒、99 パーセンタイル ≤ 3 秒 |

---

## 11️⃣ テスト仕様書 / テストケースシート

> 以下は抜粋。実際のスプレッドシート/Excel に転記して管理。

| TC ID | 機能 | 前提条件 | 入力データ | 手順 | 期待結果 |
|-------|------|----------|------------|------|-----------|
| TC‑01 | 社員情報取得 | `employees` テーブルに `E001` が存在 | GET `/api/v1/employees/E001` | API 呼び出し | 200 OK、JSON に正しい `name`, `email` が含まれる |
| TC‑02 | 医師スケジュール登録 | Doctor `doc-123` が存在 | POST `/api/v1/doctorschedules` (body: `{ doctorId:"doc-123", startUtc:"2026-01-15T09:00:00Z", endUtc:"2026-01-15T12:00:00Z" }`) | API 呼び出し | 201 Created、スケジュールが DB に保存 |
| TC‑03 | 予約作成（成功） | Doctor スケジュール内に空きあり、Employee `E001` 存在 | POST `/api/v1/reservations` (body: `{ doctorId:"doc-123", employeeNumber:"E001", startUtc:"2026-01-15T09:30:00Z", endUtc:"2026-01-15T10:00:00Z" }`) | API 呼び出し | 201 Created、メールログに `To:E001@example.com` が出力 |
| TC‑04 | 予約作成（時間重複エラー） | 同上 + 既存予約が同時間帯に存在 | 同上だが開始時刻を `09:45` に変更 | API 呼び出し | 400 Bad Request、メッセージ “Reservation overlaps existing booking” |
| TC‑05 | リマインダー自動送信（Cron） | ReminderConfig (3日前・9時) が登録、対象予約が 2026‑02‑10 09:00 に設定 | 手動で `docker exec backend npm run start:cron`（テスト用） | ログに “Sending reminder for reservation …” が出力 | `ReminderSent` テーブルにレコードが作成 |
| TC‑06 | 診療曜日フィルタ表示 | Workday に `[1,2,3,4,5]` (月〜金) が設定 | UI でカレンダーを開く | カレンダーセルの色・非活性確認 | 土日がグレーアウト、平日のみクリック可能 |
| TC‑07 | バックアップ実行 | DB が稼働中 | `docker exec db pg_dump -U postgres healthapp > /backup/healthapp_$(date +%F).dump` | 手動コマンド実行 | `/backup` ディレクトリに `.dump` ファイルが生成、OneDrive 同期が開始 |

---

## 12️⃣ リリースノート / デプロイメントガイド

| バージョン | リリース日 | 主な新機能・改善 |
|------------|------------|-------------------|
| **0.1‑alpha** | 2025‑12‑22 | 初期構成（Docker Compose、Mock 社員データ）<br>予約作成・医師スケジュール管理 UI<br>リマインダー Cron (Mock メールログ) |
| **0.2‑beta** | TBD | Azure AD OIDC 認証実装<br>HTTPS/TLS 終端（Nginx）<br>メール送信を Microsoft Graph に切替 |
| **1.0‑release** | TBD | 本番環境デプロイ（Azure VM / AKS）<br>パフォーマンスチューニング (キャッシュ) <br>監視・アラート設定 (Azure Monitor) |

### デプロイ手順（Docker Compose）

1. **コード取得 & ビルド**  
   ```bash
   git clone <repo-url>
   cd health-app
   cp .env.example .env      # 必要に応じて編集
   npm ci                     # ワークスペース全体の依存インストール
   npx prisma migrate dev     # DB スキーマ適用（開発 DB）
   docker compose up -d       # コンテナ起動
   ```
2. **ローカルで動作確認**  
   - フロント: `http://localhost`  
   - バックエンド API: `http://localhost:3000/api/v1/...`  

3. **本番環境へデプロイ（例：Azure VM）**  
   - VM に Docker Engine と Docker Compose をインストール。  
   - リポジトリをクローンし、`.env.production` で本番用 DB 接続・JWT シークレット等を設定。  
   - `docker compose -f docker-compose.yml up -d` → 起動。  

4. **ロールバック**（Docker Compose）  
   ```bash
   docker compose down               # 現行コンテナ停止
   git checkout <前のタグ>
   docker compose up -d              # 前バージョンで再起動
   ```

### 環境別差分

| 項目 | 開発環境 (WSL) | 本番環境 (Azure VM) |
|------|----------------|--------------------|
| **DB 接続** | `postgresql://postgres:postgres@db:5432/healthapp`（Docker 内） | Azure Database for PostgreSQL の接続文字列 |
| **TLS** | なし（HTTP） | Nginx に証明書 (`/etc/nginx/certs/*.pem`) を配置し HTTPS 有効化 |
| **認証** | Mock (無) | Azure AD OIDC + JWT |
| **バックアップ先** | OneDrive 同期フォルダ（ローカル） | Azure Blob Storage (定期スナップショット) |
| **ログ保管** | Docker ログローテーション、`logs/` ディレクトリ | Azure Log Analytics に転送 |

---

## 13️⃣ 運用マニュアル

### 13‑1️⃣ 日次・週次・月次の保守作業リスト

| 頻度 | 作業項目 | 手順 |
|------|----------|------|
| **日次** | バックアップ確認 | `ls -l /backup/*.dump` → 最新ファイルが存在するかチェック。 |
|  | ログローテーション | `docker logs backend --since 24h > logs/backend_$(date +%F).log` |
| **週次** | OneDrive 同期状態確認 | OneDrive クライアントのステータス → “アップロード完了”。 |
|  | DB 健康チェック | `docker exec db pg_isready`、エラーログが無いか確認。 |
| **月次** | ディスク使用量レポート | `du -sh /var/lib/docker/volumes/*` → 10 GB 超えていたらアーカイブ。 |
|  | セキュリティパッチ適用 | `npm audit fix`、Docker イメージ再ビルド (`docker compose build`) |

### 13‑2️⃣ 障害時トラブルシューティングフロー

1. **インシデント検知**（監視ツール / 手動）  
   - アプリが応答しない、またはエラーが大量に出た場合。 |
2. **一次調査**  
   - `docker ps` → コンテナのステータス確認。<br>- `docker logs <コンテナ名>` で直近ログ取得。 |
3. **切り分け**  
   - フロントが問題かバックエンドか判定（curl で API 呼び出し）。 |
4. **復旧**  
   - コンテナ再起動：`docker compose restart <service>`<br>- DB が落ちた場合は `docker exec db pg_ctl restart`。 |
5. **根本原因分析 (RCA)**  
   - 再現手順をドキュメント化し、次回リリースで修正。 |
6. **報告**  
   - インシデントレポート（発生日・影響範囲・復旧時間）を Slack / Teams に共有。 |

### 13‑3️⃣ ログ閲覧・分析手順

- **バックエンドログ**：`docker logs backend --tail 100`（リアルタイム）  
- **フロントデバッグ**：Chrome DevTools → Network タブで API 呼び出し確認。  
- **メール送信ログ**：`cat logs/email.log | grep "<社員番号>"`  

### 13‑4️⃣ バックアップ / リカバリ手順

1. **バックアップ取得（自動）**  
   - `docker exec db pg_dump -U postgres healthapp > /backup/healthapp_$(date +%F).dump` が毎日 00:00 に実行。 |
2. **復元手順**（障害時）  
   ```bash
   docker exec -i db psql -U postgres -d healthapp < /backup/healthapp_<対象日>.dump
   ```
3. **リカバリテスト**（月次）  
   - テスト用 DB を作成し、バックアップから復元できるか検証。  

### 13‑5️⃣ キャパシティプランニング指標

| 指標 | 現在値 (開発) | 推奨上限 | コメント |
|------|--------------|----------|-----------|
| **CPU 使用率** | <30%（平均） | ≤70% | スケールアウトの目安。 |
| **メモリ使用量** | 1.2 GB / コンテナ | ≤3 GB / コンテナ | メモリ不足時は `docker compose up --scale backend=2` 等で水平スケーリング検討。 |
| **ディスク容量 (DB)** | 500 MB | ≤5 GB | バックアップ保持期間に応じて増減。 |

---

### ★まとめ

- 本ドキュメントは **要件・設計・テスト・運用** を一貫して網羅し、プロジェクトの全ライフサイクルを俯瞰できるよう構成しました。  
- 現在は **Mock モード** が前提で、社内 PC の WSL2 上に Docker Compose だけで完結する構造です。  
- 将来的な本番移行（Azure AD 認証・TLS・外部 DB）やスケールアウトの計画は **TBD** として残していますが、各項目はすでに設計上のフック（モジュール分割、DI、Cron）を入れているため、追加実装は比較的容易です。  

> 次のステップとして、**テストケースの詳細化・CI の本番パイプライン構築**、そして **本番環境へのデプロイ計画（Azure VM / AKS）** を具体化していくことを推奨します。質問や追加要件が出た際は随時更新してください。 🙌